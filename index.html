<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Service Matcher</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Basic animation for the loader */
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* blue-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        /* Custom scrollbar for the results table */
        .table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .table-container::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
            border-radius: 10px;
        }
        .table-container::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 10px;
        }
        .table-container::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }
        /* Sorting indicators */
        .sort-header {
            cursor: pointer;
            user-select: none;
        }
        .sort-header:hover {
            background-color: #e2e8f0; /* slate-200 */
        }
        .sort-indicator {
            margin-left: 4px;
            opacity: 0.5;
        }
        .sort-indicator.active {
            opacity: 1;
        }
        /* Column filter chips */
        .column-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background-color: #e2e8f0; /* slate-200 */
            border-radius: 0.375rem;
            font-size: 0.75rem;
            margin: 0.125rem;
        }
        .column-chip-remove {
            cursor: pointer;
            font-weight: bold;
            color: #64748b; /* slate-500 */
        }
        .column-chip-remove:hover {
            color: #ef4444; /* red-500 */
        }
    </style>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="bg-slate-100 text-slate-800 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl bg-white rounded-xl shadow-lg p-6 md:p-8 space-y-6">
        <!-- Header Section -->
        <div>
            <h1 class="text-3xl font-bold text-slate-900">CSV Service Matcher</h1>
            <p class="mt-2 text-slate-600">Upload two CSV files. The tool will find service names from the second file within the 'Summary' column of the first file and merge the data.</p>
        </div>

        <!-- File Upload Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 pt-4 border-t border-slate-200">
            <!-- JIRA CSV Input -->
            <div>
                <label for="jira-file" class="block text-sm font-medium text-slate-700 mb-1">1. Upload JIRA CSV</label>
                <p class="text-xs text-slate-500 mb-2">Must contain a "Summary" column.</p>
                <input type="file" id="jira-file" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors duration-200"/>
            </div>
            <!-- Services CSV Input -->
            <div>
                <label for="services-file" class="block text-sm font-medium text-slate-700 mb-1">2. Upload Services CSV</label>
                <p class="text-xs text-slate-500 mb-2">Must contain a "Service0" column.</p>
                <input type="file" id="services-file" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 transition-colors duration-200"/>
            </div>
        </div>
        
        <!-- Action Button -->
        <div class="flex justify-center pt-4">
            <button id="process-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform duration-200 hover:scale-105 disabled:bg-slate-400 disabled:cursor-not-allowed disabled:scale-100">
                Process Files
            </button>
        </div>

        <!-- Table Controls (Initially Hidden) -->
        <div id="table-controls" class="hidden space-y-4 pt-4 border-t border-slate-200">
            <!-- Sort Controls -->
            <div class="flex flex-col sm:flex-row gap-4 items-start sm:items-center">
                <div class="flex items-center gap-2">
                    <label for="sort-column" class="text-sm font-medium text-slate-700">Sort by:</label>
                    <select id="sort-column" class="px-3 py-1 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="">Select column...</option>
                    </select>
                    <button id="sort-direction" class="px-3 py-1 border border-slate-300 rounded-md text-sm hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        ↑ ASC
                    </button>
                </div>
                
                <!-- Show Unhealthy Only Toggle -->
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="show-unhealthy-only" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2">
                    <label for="show-unhealthy-only" class="text-sm font-medium text-slate-700">Show unhealthy only</label>
                </div>
            </div>
            
            <!-- Column Filter -->
            <div>
                <div class="flex justify-between items-center mb-2">
                    <label class="text-sm font-medium text-slate-700">Visible Columns:</label>
                    <button id="show-all-columns" class="text-xs px-2 py-1 bg-slate-200 text-slate-700 rounded hover:bg-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        Show All
                    </button>
                </div>
                <div id="column-filter" class="border border-slate-300 rounded-md p-3 min-h-[2.5rem] bg-white">
                    <!-- Column chips will be added here dynamically -->
                </div>
                <p class="text-xs text-slate-500 mt-1">Click the × next to a column name to hide it from the table.</p>
            </div>
        </div>

        <!-- Error and Loading Section -->
        <div id="status-container" class="text-center p-4"></div>

        <!-- Results Section -->
        <div id="results-container" class="hidden space-y-4">
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4 pt-4 border-t border-slate-200">
                 <h2 class="text-2xl font-bold text-slate-900">Merged Data</h2>
                 <button id="download-btn" class="bg-green-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-transform duration-200 hover:scale-105">
                    Download Merged CSV
                </button>
            </div>
            <p id="summary-text" class="text-sm text-slate-600"></p>
            <div class="table-container w-full overflow-x-auto border border-slate-200 rounded-lg max-h-[50vh]">
                <table id="results-table" class="w-full text-sm text-left text-slate-600">
                    <!-- Table content will be generated by JavaScript -->
                </table>
            </div>
        </div>

    </div>

    <script>
        // DOM element references
        const jiraFileInput = document.getElementById('jira-file');
        const servicesFileInput = document.getElementById('services-file');
        const processBtn = document.getElementById('process-btn');
        const statusContainer = document.getElementById('status-container');
        const resultsContainer = document.getElementById('results-container');
        const downloadBtn = document.getElementById('download-btn');
        const resultsTable = document.getElementById('results-table');
        const summaryText = document.getElementById('summary-text');
        const tableControls = document.getElementById('table-controls');
        const sortColumnSelect = document.getElementById('sort-column');
        const sortDirectionBtn = document.getElementById('sort-direction');
        const columnFilter = document.getElementById('column-filter');
        const showAllColumnsBtn = document.getElementById('show-all-columns');
        const showUnhealthyOnlyToggle = document.getElementById('show-unhealthy-only');
        
        let mergedData = [];
        let mergedHeaders = [];
        let visibleHeaders = [];
        let sortColumn = '';
        let sortDirection = 'asc';
        let servicesFileName = '';
        let showUnhealthyOnly = false;

        /**
         * Parses HTML content to extract links and text separately.
         * @param {string} content - The HTML content to parse.
         * @returns {Object} Object with extracted links and text.
         */
        const parseHtmlContent = (content) => {
            if (!content || typeof content !== 'string') return { text: content || '', links: [] };
            
            // Create a temporary element to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            
            const links = [];
            const anchors = tempDiv.querySelectorAll('a[href]');
            
            anchors.forEach((anchor, index) => {
                links.push({
                    url: anchor.href,
                    text: anchor.textContent || anchor.href
                });
            });
            
            // Get text content without the links
            let textContent = tempDiv.textContent || tempDiv.innerText || '';
            
            return { text: textContent.trim(), links };
        };

        /**
         * Expands columns that contain multiple links into separate columns.
         * @param {Array<Object>} data - The data to process.
         * @returns {Object} Object with expanded data and new headers.
         */
        const expandLinksIntoColumns = (data) => {
            if (data.length === 0) return { expandedData: data, newHeaders: [] };
            
            const expandedData = [];
            const additionalHeaders = new Set();
            
            data.forEach(row => {
                const newRow = {};
                
                Object.keys(row).forEach(column => {
                    const content = row[column] || '';
                    const parsed = parseHtmlContent(content);
                    
                    if (parsed.links.length > 0) {
                        // If there's text content, keep the original column for text
                        if (parsed.text) {
                            newRow[column] = parsed.text;
                        } else {
                            newRow[column] = '';
                        }
                        
                        // Create separate columns for each link
                        parsed.links.forEach((link, index) => {
                            const linkColumnName = parsed.links.length === 1 
                                ? `${column}_Link` 
                                : `${column}_Link_${index + 1}`;
                            newRow[linkColumnName] = link.url;
                            additionalHeaders.add(linkColumnName);
                        });
                    } else {
                        // No links, keep original content
                        newRow[column] = content;
                    }
                });
                
                expandedData.push(newRow);
            });
            
            return { expandedData, newHeaders: Array.from(additionalHeaders) };
        };

        /**
         * Sorts the merged data by a specific column.
         * @param {Array<Object>} data - The data to sort.
         * @param {string} column - The column to sort by.
         * @param {string} direction - 'asc' or 'desc'.
         * @returns {Array<Object>} The sorted data.
         */
        const sortData = (data, column, direction) => {
            if (!column) return data;
            
            return [...data].sort((a, b) => {
                const aVal = a[column] || '';
                const bVal = b[column] || '';
                
                // Try to parse as numbers first
                const aNum = parseFloat(aVal);
                const bNum = parseFloat(bVal);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return direction === 'asc' ? aNum - bNum : bNum - aNum;
                }
                
                // Otherwise sort as strings
                const comparison = aVal.toString().localeCompare(bVal.toString());
                return direction === 'asc' ? comparison : -comparison;
            });
        };

        /**
         * Initializes the sort column dropdown.
         * @param {Array<string>} headers - Available column headers.
         */
        const initializeSortOptions = (headers) => {
            sortColumnSelect.innerHTML = '<option value="">Select column...</option>';
            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                sortColumnSelect.appendChild(option);
            });
        };

        /**
         * Creates column filter chips.
         * @param {Array<string>} headers - All available headers.
         * @param {Array<string>} visible - Currently visible headers (optional).
         */
        const createColumnFilter = (headers, visible = null) => {
            columnFilter.innerHTML = '';
            if (visible === null) {
                visibleHeaders = [...headers]; // Initialize all columns as visible only if not provided
            }
            
            headers.forEach(header => {
                const chip = document.createElement('span');
                chip.className = 'column-chip';
                chip.style.display = visibleHeaders.includes(header) ? 'inline-flex' : 'none';
                chip.innerHTML = `
                    ${header}
                    <span class="column-chip-remove" data-column="${header}">×</span>
                `;
                columnFilter.appendChild(chip);
            });
        };

        /**
         * Removes a column from the visible headers and updates the display.
         * @param {string} columnToRemove - The column to hide.
         */
        const removeColumn = (columnToRemove) => {
            visibleHeaders = visibleHeaders.filter(h => h !== columnToRemove);
            createColumnFilter(mergedHeaders, visibleHeaders);
            refreshTable();
        };

        /**
         * Shows all columns again.
         */
        const showAllColumns = () => {
            visibleHeaders = [...mergedHeaders];
            createColumnFilter(mergedHeaders, visibleHeaders);
            refreshTable();
        };

        /**
         * Refreshes the table with current sort and filter settings.
         */
        const refreshTable = () => {
            let dataToShow = [...mergedData];
            
            // Apply unhealthy filter if enabled
            if (showUnhealthyOnly) {
                dataToShow = dataToShow.filter(row => {
                    const status0 = (row['Status0'] || '').toUpperCase();
                    return !status0.includes('FULL_SERVICE');
                });
            }
            
            const sortedData = sortData(dataToShow, sortColumn, sortDirection);
            displayTable(sortedData, visibleHeaders);
        };

        /**
         * Reprocesses the data with current settings.
         */
        const reprocessData = () => {
            if (mergedData.length === 0) return;
            
            // Get the original data from global variables
            if (window.originalJiraData && window.originalServicesData) {
                showUnhealthyOnly = showUnhealthyOnlyToggle.checked;
                const { mergedData: reprocessedData, matchesFound } = processData(window.originalJiraData, window.originalServicesData);
                mergedData = reprocessedData;
                summaryText.textContent = `Processing complete. Found ${matchesFound} matches across ${window.originalJiraData.length} JIRA entries.`;
                refreshTable();
            }
        };

        /**
         * Parses CSV text into an array of objects.
         * It intelligently finds the header row by looking for a key column.
         * @param {string} text - The CSV content as a string.
         * @param {string} keyColumn - A column name that is expected to be in the header.
         * @returns {Array<Object>} An array of objects representing rows.
         */
        const parseCSV = (text, keyColumn) => {
            const lines = text.trim().split(/\r?\n/);
            if (lines.length === 0) return [];

            let headerLineIndex = -1;
            let header = [];

            // Search for the header row in the first 10 lines of the file
            const searchLimit = Math.min(lines.length, 10);
            for (let i = 0; i < searchLimit; i++) {
                // Clean up potential header values
                const potentialHeader = lines[i].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
                if (potentialHeader.includes(keyColumn)) {
                    headerLineIndex = i;
                    header = potentialHeader;
                    break;
                }
            }

            // If no header is found, we can't process the file
            if (headerLineIndex === -1) {
                return [];
            }

            const rows = lines
                .slice(headerLineIndex + 1)
                .map(line => {
                    // Ignore empty lines which might be present in the CSV
                    if (line.trim() === '') return null;

                    const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.trim().replace(/^"|"$/g, ''));
                    const rowObject = {};
                    header.forEach((col, index) => {
                        // Create object properties, skipping columns with no header name
                        if (col) {
                           rowObject[col] = values[index];
                        }
                    });
                    return rowObject;
                })
                .filter(row => row !== null); // Remove the empty lines we marked as null

            return rows;
        };
        
        /**
         * Reads a file and returns its content as text.
         * @param {File} file - The file to read.
         * @returns {Promise<string>} A promise that resolves with the file content.
         */
        const readFileAsText = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsText(file);
            });
        };

        /**
         * Merges JIRA and Services data based on the matching logic.
         * @param {Array<Object>} jiraData - Parsed JIRA CSV data.
         * @param {Array<Object>} servicesData - Parsed Services CSV data.
         * @returns {{mergedData: Array<Object>, matchesFound: number}} The merged data and match count.
         */
        const processData = (jiraData, servicesData) => {
            let matchesFound = 0;
            const processedData = jiraData.map(jiraRow => {
                const newRow = { ...jiraRow };
                const summary = (jiraRow['Summary'] || '').toLowerCase();
                let matchFoundForRow = false;

                // Add Environment column with the services file name
                newRow['Environment'] = servicesFileName;

                if (summary) {
                    for (const serviceRow of servicesData) {
                        let serviceName = (serviceRow['Service0'] || '').toLowerCase();
                        
                        // Always ignore headless suffixes
                        if (serviceName.endsWith('-headless')) {
                            serviceName = serviceName.replace(/-headless$/, '');
                        }
                        
                        if (serviceName && summary.includes(serviceName)) {
                            // Match found, extend the JIRA row with service data
                            Object.assign(newRow, serviceRow);
                            matchesFound++;
                            matchFoundForRow = true;
                            break; // Stop after the first match for this JIRA row
                        }
                    }
                }

                // Add "Is Same Version" column logic
                const version0 = newRow['Version0'];
                if (version0) {
                    const summaryOriginal = jiraRow['Summary'] || '';
                    const version0Lower = version0.toLowerCase();
                    
                    let isMatch = false;
                    
                    // Look for version patterns like production_w42_20251013 in the summary
                    // Pattern: word_w##_########
                    const versionPattern = /\b([a-zA-Z]+)_(w\d+)_(\d{8})\b/g;
                    const matches = summaryOriginal.toLowerCase().match(versionPattern);
                    
                    if (matches) {
                        // Check each version pattern found in summary
                        for (const match of matches) {
                            const parts = match.split('_');
                            if (parts.length === 3) {
                                const [environment, week, date] = parts;
                                
                                // Check if all three parts exist in Version0
                                if (version0Lower.includes(environment) && 
                                    version0Lower.includes(week) && 
                                    version0Lower.includes(date)) {
                                    isMatch = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // If no pattern found, fall back to simple inclusion check
                    if (!matches) {
                        isMatch = version0Lower.includes(summaryOriginal.toLowerCase());
                    }
                    
                    newRow['Is Same Version'] = isMatch ? 'true' : 'false';
                } else {
                    // If Version0 doesn't exist, leave empty
                    newRow['Is Same Version'] = '';
                }

                return newRow;
            });
            return { mergedData: processedData, matchesFound };
        };

        /**
         * Displays the merged data in an HTML table.
         * @param {Array<Object>} data - The merged data.
         * @param {Array<string>} headers - The headers for the table.
         */
        const displayTable = (data, headers) => {
            resultsTable.innerHTML = ''; // Clear previous results
            
            // Create table head
            const thead = document.createElement('thead');
            thead.className = "text-xs text-slate-700 uppercase bg-slate-50 sticky top-0";
            const headerRow = document.createElement('tr');
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.scope = 'col';
                th.className = 'px-6 py-3 sort-header';
                th.setAttribute('data-column', headerText);
                
                // Add header text and sort indicator
                const headerContent = document.createElement('div');
                headerContent.className = 'flex items-center justify-between';
                headerContent.innerHTML = `
                    <span>${headerText}</span>
                    <span class="sort-indicator ${sortColumn === headerText ? 'active' : ''}">${
                        sortColumn === headerText 
                            ? (sortDirection === 'asc' ? '↑' : '↓')
                            : '↕'
                    }</span>
                `;
                th.appendChild(headerContent);
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            resultsTable.appendChild(thead);

            // Create table body
            const tbody = document.createElement('tbody');
            data.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.className = index % 2 === 0 ? 'bg-white border-b' : 'bg-slate-50 border-b';
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4';
                    td.textContent = row[header] || ''; // Use empty string for missing values
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            resultsTable.appendChild(tbody);
        };
        
        /**
         * Converts an array of objects to a CSV string.
         * @param {Array<Object>} data - The data to convert.
         * @param {Array<string>} headers - The headers for the CSV.
         * @returns {string} The CSV content as a string.
         */
        const convertToCSV = (data, headers) => {
            const headerRow = headers.map(h => `"${h.replace(/"/g, '""')}"`).join(',');
            const bodyRows = data.map(row => {
                return headers.map(header => {
                    const value = row[header] === undefined || row[header] === null ? '' : String(row[header]);
                    return `"${value.replace(/"/g, '""')}"`;
                }).join(',');
            });
            return [headerRow, ...bodyRows].join('\n');
        };

        /**
         * Triggers a file download.
         * @param {string} content - The content of the file.
         * @param {string} fileName - The name of the file to download.
         * @param {string} contentType - The MIME type of the file.
         */
        const downloadFile = (content, fileName, contentType) => {
            const a = document.createElement("a");
            const file = new Blob([content], { type: contentType });
            a.href = URL.createObjectURL(file);
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(a.href);
        };

        /**
         * Sets the status message and style.
         * @param {string} message - The message to display.
         * @param {'error' | 'loading' | 'success'} type - The type of message.
         */
        const setStatus = (message, type = 'error') => {
            statusContainer.innerHTML = ''; // Clear previous status
            if (!message) return;
            
            const statusDiv = document.createElement('div');
            let classes = 'p-4 rounded-lg text-sm ';
            
            if (type === 'error') {
                classes += 'bg-red-100 text-red-700';
                statusDiv.textContent = `Error: ${message}`;
            } else if (type === 'loading') {
                classes += 'bg-blue-100 text-blue-700 flex items-center justify-center gap-3';
                const loader = document.createElement('div');
                loader.className = 'loader';
                statusDiv.appendChild(loader);
                statusDiv.append(message);
            } else { // success
                classes += 'bg-green-100 text-green-700';
                statusDiv.textContent = message;
            }
            
            statusDiv.className = classes;
            statusContainer.appendChild(statusDiv);
        };
        
        // --- Event Handlers ---

        const handleProcess = async () => {
            const jiraFile = jiraFileInput.files[0];
            const servicesFile = servicesFileInput.files[0];

            // 1. Validation
            if (!jiraFile || !servicesFile) {
                setStatus('Please select both CSV files.');
                return;
            }
            setStatus('Processing files...', 'loading');
            processBtn.disabled = true;
            resultsContainer.classList.add('hidden');
            tableControls.classList.add('hidden');

            try {
                // 2. Store services file name, get toggle state, and read files
                servicesFileName = servicesFile.name.replace('.csv', '');
                showUnhealthyOnly = showUnhealthyOnlyToggle.checked;
                
                const [jiraText, servicesText] = await Promise.all([
                    readFileAsText(jiraFile),
                    readFileAsText(servicesFile)
                ]);

                const jiraData = parseCSV(jiraText, 'Summary');
                const servicesData = parseCSV(servicesText, 'Service0');
                
                // Store original data globally for reprocessing
                window.originalJiraData = jiraData;
                window.originalServicesData = servicesData;
                
                // 3. Check for required columns
                if (jiraData.length === 0) {
                    throw new Error('JIRA CSV is missing data or the "Summary" column could not be found.');
                }
                if (servicesData.length === 0) {
                    throw new Error('Services CSV is missing data or the "Service0" column could not be found.');
                }

                // 4. Process the data
                const { mergedData: processedData, matchesFound } = processData(jiraData, servicesData);
                
                // 4.5. Expand columns with multiple links
                const { expandedData, newHeaders: linkHeaders } = expandLinksIntoColumns(processedData);
                mergedData = expandedData; // Store globally for download

                // 5. Determine all unique headers for the final table (including Environment, Is Same Version, and link columns)
                const jiraHeaders = Object.keys(jiraData[0] || {});
                const servicesHeaders = Object.keys(servicesData[0] || {});
                mergedHeaders = [...new Set(['Environment', ...jiraHeaders, ...servicesHeaders, 'Is Same Version', ...linkHeaders])]; // Store globally with Environment first and Is Same Version last

                // 6. Display results
                initializeSortOptions(mergedHeaders);
                createColumnFilter(mergedHeaders);
                displayTable(mergedData, visibleHeaders);
                summaryText.textContent = `Processing complete. Found ${matchesFound} matches across ${jiraData.length} JIRA entries.`;
                setStatus('', 'success'); // Clear loading status
                resultsContainer.classList.remove('hidden');
                tableControls.classList.remove('hidden');

            } catch (error) {
                console.error("Processing failed:", error);
                setStatus(error.message || 'An unexpected error occurred.');
                resultsContainer.classList.add('hidden');
                tableControls.classList.add('hidden');
            } finally {
                processBtn.disabled = false;
            }
        };

        const handleDownload = () => {
            if (mergedData.length === 0) {
                setStatus('No data available to download.');
                return;
            }
            const sortedData = sortData(mergedData, sortColumn, sortDirection);
            const csvContent = convertToCSV(sortedData, visibleHeaders);
            downloadFile(csvContent, 'merged_jira_data.csv', 'text/csv;charset=utf-8;');
        };

        // --- Attach Event Listeners ---
        processBtn.addEventListener('click', handleProcess);
        downloadBtn.addEventListener('click', handleDownload);
        
        // Sort controls
        sortColumnSelect.addEventListener('change', (e) => {
            sortColumn = e.target.value;
            refreshTable();
        });
        
        sortDirectionBtn.addEventListener('click', () => {
            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            sortDirectionBtn.textContent = sortDirection === 'asc' ? '↑ ASC' : '↓ DESC';
            refreshTable();
        });
        
        // Table header clicks for sorting
        resultsTable.addEventListener('click', (e) => {
            const header = e.target.closest('.sort-header');
            if (header) {
                const column = header.getAttribute('data-column');
                if (sortColumn === column) {
                    sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    sortColumn = column;
                    sortDirection = 'asc';
                }
                sortColumnSelect.value = sortColumn;
                sortDirectionBtn.textContent = sortDirection === 'asc' ? '↑ ASC' : '↓ DESC';
                refreshTable();
            }
        });
        
        // Column filter chips
        columnFilter.addEventListener('click', (e) => {
            if (e.target.classList.contains('column-chip-remove')) {
                const columnToRemove = e.target.getAttribute('data-column');
                removeColumn(columnToRemove);
            }
        });
        
        // Show all columns button
        showAllColumnsBtn.addEventListener('click', showAllColumns);
        
        // Show unhealthy only toggle
        showUnhealthyOnlyToggle.addEventListener('change', () => {
            showUnhealthyOnly = showUnhealthyOnlyToggle.checked;
            refreshTable();
        });
    </script>

</body>
</html>

