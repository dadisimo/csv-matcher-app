<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Service Matcher</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* Custom font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Basic animation for the loader */
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* blue-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        /* Custom scrollbar for the results table */
        .table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .table-container::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
            border-radius: 10px;
        }
        .table-container::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 10px;
        }
        .table-container::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }
        /* Sorting indicators */
        .sort-header {
            cursor: pointer;
            user-select: none;
        }
        .sort-header:hover {
            background-color: #e2e8f0; /* slate-200 */
        }
        .sort-indicator {
            margin-left: 4px;
            opacity: 0.5;
        }
        .sort-indicator.active {
            opacity: 1;
        }
        /* Column filter chips */
        .column-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background-color: #e2e8f0; /* slate-200 */
            border-radius: 0.375rem;
            font-size: 0.75rem;
            margin: 0.125rem;
        }
        .column-chip-remove {
            cursor: pointer;
            font-weight: bold;
            color: #64748b; /* slate-500 */
        }
        .column-chip-remove:hover {
            color: #ef4444; /* red-500 */
        }
        /* Editable table cells */
        .editable-cell {
            cursor: text;
            position: relative;
        }
        .editable-cell:hover {
            background-color: #f8fafc; /* slate-50 */
        }
        .cell-editor {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #3b82f6; /* blue-500 */
            padding: 8px;
            background: white;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            resize: none;
        }
    </style>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="bg-slate-100 text-slate-800 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl bg-white rounded-xl shadow-lg p-6 md:p-8 space-y-6">
        <!-- Header Section -->
        <div>
            <h1 class="text-3xl font-bold text-slate-900">CSV Service Matcher</h1>
            <p class="mt-2 text-slate-600">Upload two CSV files. The tool will find service names from the second file within the 'Summary' column of the first file and merge the data.</p>
        </div>

        <!-- File Upload Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 pt-4 border-t border-slate-200">
            <!-- JIRA CSV Input -->
            <div>
                <label for="jira-file" class="block text-sm font-medium text-slate-700 mb-1">1. Upload JIRA CSV</label>
                <p class="text-xs text-slate-500 mb-2">Must contain a "Summary" column.</p>
                <input type="file" id="jira-file" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors duration-200"/>
            </div>
            <!-- Services CSV Input -->
            <div>
                <label for="services-file" class="block text-sm font-medium text-slate-700 mb-1">2. Upload Services CSV(s)</label>
                <p class="text-xs text-slate-500 mb-2">Must contain a "Service0" column. You can select multiple files.</p>
                <input type="file" id="services-file" accept=".csv" multiple class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 transition-colors duration-200"/>
            </div>
        </div>
        
        <!-- Action Button -->
        <div class="flex justify-center pt-4">
            <button id="process-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform duration-200 hover:scale-105 disabled:bg-slate-400 disabled:cursor-not-allowed disabled:scale-100">
                Process Files
            </button>
        </div>

        <!-- Table Controls (Initially Hidden) -->
        <div id="table-controls" class="hidden space-y-4 pt-4 border-t border-slate-200">
            <!-- Sort Controls -->
            <div class="flex flex-col sm:flex-row gap-4 items-start sm:items-center">
                <div class="flex items-center gap-2">
                    <label for="sort-column" class="text-sm font-medium text-slate-700">Sort by:</label>
                    <select id="sort-column" class="px-3 py-1 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="">Select column...</option>
                    </select>
                    <button id="sort-direction" class="px-3 py-1 border border-slate-300 rounded-md text-sm hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        ↑ ASC
                    </button>
                </div>
                
                <!-- Show Unhealthy Only Toggle -->
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="show-unhealthy-only" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2">
                    <label for="show-unhealthy-only" class="text-sm font-medium text-slate-700">Show unhealthy only</label>
                </div>
                
                <!-- Show Unequal Versions Only Toggle -->
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="show-unequal-versions-only" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2">
                    <label for="show-unequal-versions-only" class="text-sm font-medium text-slate-700">Show unequal versions only</label>
                </div>
            </div>
            
            <!-- Column Filter -->
            <div>
                <div class="flex justify-between items-center mb-2">
                    <label class="text-sm font-medium text-slate-700">Visible Columns:</label>
                    <button id="show-all-columns" class="text-xs px-2 py-1 bg-slate-200 text-slate-700 rounded hover:bg-slate-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        Show All
                    </button>
                </div>
                <div id="column-filter" class="border border-slate-300 rounded-md p-3 min-h-[2.5rem] bg-white">
                    <!-- Column chips will be added here dynamically -->
                </div>
                <p class="text-xs text-slate-500 mt-1">Click the × next to a column name to hide it from the table.</p>
            </div>
        </div>

        <!-- Error and Loading Section -->
        <div id="status-container" class="text-center p-4"></div>

        <!-- Results Section -->
        <div id="results-container" class="hidden space-y-4">
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4 pt-4 border-t border-slate-200">
                 <h2 class="text-2xl font-bold text-slate-900">Merged Data</h2>
                 <div class="flex gap-2">
                     <button id="settings-btn" class="bg-gray-600 text-white font-bold py-2 px-3 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-transform duration-200 hover:scale-105" title="Settings">
                        ⚙️
                    </button>
                     <button id="add-jira-links-btn" class="bg-orange-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500 transition-transform duration-200 hover:scale-105">
                        Add Jira Links
                    </button>
                     <button id="copy-slack-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform duration-200 hover:scale-105">
                        Copy as Image
                    </button>
                     <button id="download-btn" class="bg-green-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-transform duration-200 hover:scale-105">
                        Download Merged CSV
                    </button>
                 </div>
            </div>
            <p id="summary-text" class="text-sm text-slate-600"></p>
            <div class="table-container w-full overflow-x-auto border border-slate-200 rounded-lg max-h-[50vh]">
                <table id="results-table" class="w-full text-sm text-left text-slate-600">
                    <!-- Table content will be generated by JavaScript -->
                </table>
            </div>
            
            <!-- Row Management Buttons -->
            <div class="flex justify-between items-center pt-4 border-t border-slate-200">
                <div class="flex gap-2">
                    <button id="delete-selected-btn" class="bg-red-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-transform duration-200 hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        Delete Selected Rows
                    </button>
                    <button id="restore-rows-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform duration-200 hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        Restore Deleted Rows
                    </button>
                </div>
                <div id="selection-info" class="text-sm text-slate-600">
                    <!-- Selection info will be displayed here -->
                </div>
            </div>
        </div>

    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden">
            <!-- Settings Header -->
            <div class="bg-gray-50 px-6 py-4 border-b border-gray-200 flex items-center justify-between">
                <h2 class="text-xl font-bold text-gray-900">Settings</h2>
                <button id="settings-back-btn" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200">
                    ← Back
                </button>
            </div>
            
            <!-- Settings Content -->
            <div class="p-6 overflow-y-auto max-h-[calc(90vh-120px)]">
                <div class="space-y-6">
                    <!-- Jira Deployment Links Section -->
                    <div>
                        <label for="jira-deployment-links" class="block text-sm font-medium text-gray-700 mb-2">
                            Jira Deployment Links
                        </label>
                        <p class="text-sm text-gray-500 mb-3">
                            Enter deployment links, one per line. These links will be used for generating deployment references.
                        </p>
                        <textarea 
                            id="jira-deployment-links" 
                            rows="10" 
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono text-sm"
                            placeholder="https://example.com/deployment1&#10;https://example.com/deployment2&#10;https://example.com/deployment3"
                        ></textarea>
                        <p class="text-xs text-gray-400 mt-2">
                            Changes are automatically saved when you go back to the main window.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM element references
        const jiraFileInput = document.getElementById('jira-file');
        const servicesFileInput = document.getElementById('services-file');
        const processBtn = document.getElementById('process-btn');
        const statusContainer = document.getElementById('status-container');
        const resultsContainer = document.getElementById('results-container');
        const downloadBtn = document.getElementById('download-btn');
        const copySlackBtn = document.getElementById('copy-slack-btn');
        const resultsTable = document.getElementById('results-table');
        const summaryText = document.getElementById('summary-text');
        const tableControls = document.getElementById('table-controls');
        const sortColumnSelect = document.getElementById('sort-column');
        const sortDirectionBtn = document.getElementById('sort-direction');
        const columnFilter = document.getElementById('column-filter');
        const showAllColumnsBtn = document.getElementById('show-all-columns');
        const showUnhealthyOnlyToggle = document.getElementById('show-unhealthy-only');
        const showUnequalVersionsOnlyToggle = document.getElementById('show-unequal-versions-only');
        const deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const restoreRowsBtn = document.getElementById('restore-rows-btn');
        const selectionInfo = document.getElementById('selection-info');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const settingsBackBtn = document.getElementById('settings-back-btn');
        const jiraDeploymentLinksInput = document.getElementById('jira-deployment-links');
        const addJiraLinksBtn = document.getElementById('add-jira-links-btn');
        
        let mergedData = [];
        let deletedRows = []; // Store deleted rows for restoration
        let mergedHeaders = [];
        let visibleHeaders = [];
        let sortColumn = '';
        let sortDirection = 'asc';
        let servicesFileNames = [];
        let showUnhealthyOnly = false;
        let showUnequalVersionsOnly = false;
        let customFilters = {}; // Store custom column filters

        /**
         * Parses HTML content to extract links and text separately.
         * @param {string} content - The HTML content to parse.
         * @returns {Object} Object with extracted links and text.
         */
        const parseHtmlContent = (content) => {
            if (!content || typeof content !== 'string') return { text: content || '', links: [] };
            
            // Create a temporary element to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            
            const links = [];
            const anchors = tempDiv.querySelectorAll('a[href]');
            
            anchors.forEach((anchor, index) => {
                links.push({
                    url: anchor.href,
                    text: anchor.textContent || anchor.href
                });
            });
            
            // Get text content without the links
            let textContent = tempDiv.textContent || tempDiv.innerText || '';
            
            return { text: textContent.trim(), links };
        };

        /**
         * Expands columns that contain multiple links into separate columns.
         * @param {Array<Object>} data - The data to process.
         * @returns {Object} Object with expanded data and new headers.
         */
        const expandLinksIntoColumns = (data) => {
            if (data.length === 0) return { expandedData: data, newHeaders: [] };
            
            const expandedData = [];
            const additionalHeaders = new Set();
            
            data.forEach(row => {
                const newRow = {};
                
                Object.keys(row).forEach(column => {
                    const content = row[column] || '';
                    const parsed = parseHtmlContent(content);
                    
                    if (parsed.links.length > 0) {
                        // If there's text content, keep the original column for text
                        if (parsed.text) {
                            newRow[column] = parsed.text;
                        } else {
                            newRow[column] = '';
                        }
                        
                        // Create separate columns for each link
                        parsed.links.forEach((link, index) => {
                            const linkColumnName = parsed.links.length === 1 
                                ? `${column}_Link` 
                                : `${column}_Link_${index + 1}`;
                            newRow[linkColumnName] = link.url;
                            additionalHeaders.add(linkColumnName);
                        });
                    } else {
                        // No links, keep original content
                        newRow[column] = content;
                    }
                });
                
                expandedData.push(newRow);
            });
            
            return { expandedData, newHeaders: Array.from(additionalHeaders) };
        };

        /**
         * Sorts the merged data by a specific column.
         * @param {Array<Object>} data - The data to sort.
         * @param {string} column - The column to sort by.
         * @param {string} direction - 'asc' or 'desc'.
         * @returns {Array<Object>} The sorted data.
         */
        const sortData = (data, column, direction) => {
            if (!column) return data;
            
            return [...data].sort((a, b) => {
                const aVal = a[column] || '';
                const bVal = b[column] || '';
                
                // Try to parse as numbers first
                const aNum = parseFloat(aVal);
                const bNum = parseFloat(bVal);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return direction === 'asc' ? aNum - bNum : bNum - aNum;
                }
                
                // Otherwise sort as strings
                const comparison = aVal.toString().localeCompare(bVal.toString());
                return direction === 'asc' ? comparison : -comparison;
            });
        };

        /**
         * Initializes the sort column dropdown.
         * @param {Array<string>} headers - Available column headers.
         */
        const initializeSortOptions = (headers) => {
            sortColumnSelect.innerHTML = '<option value="">Select column...</option>';
            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                sortColumnSelect.appendChild(option);
            });
        };

        /**
         * Creates column filter chips.
         * @param {Array<string>} headers - All available headers.
         * @param {Array<string>} visible - Currently visible headers (optional).
         */
        const createColumnFilter = (headers, visible = null) => {
            columnFilter.innerHTML = '';
            if (visible === null) {
                visibleHeaders = [...headers]; // Initialize all columns as visible only if not provided
            }
            
            headers.forEach(header => {
                const chip = document.createElement('span');
                chip.className = 'column-chip';
                chip.style.display = visibleHeaders.includes(header) ? 'inline-flex' : 'none';
                chip.innerHTML = `
                    ${header}
                    <span class="column-chip-remove" data-column="${header}">×</span>
                `;
                columnFilter.appendChild(chip);
            });
        };

        /**
         * Removes a column from the visible headers and updates the display.
         * @param {string} columnToRemove - The column to hide.
         */
        const removeColumn = (columnToRemove) => {
            visibleHeaders = visibleHeaders.filter(h => h !== columnToRemove);
            createColumnFilter(mergedHeaders, visibleHeaders);
            refreshTable();
        };

        /**
         * Shows all columns again.
         */
        const showAllColumns = () => {
            visibleHeaders = [...mergedHeaders];
            createColumnFilter(mergedHeaders, visibleHeaders);
            refreshTable();
        };

        /**
         * Makes a table cell editable.
         * @param {HTMLElement} cell - The cell to make editable.
         */
        const makeEditable = (cell) => {
            const currentValue = cell.textContent;
            const rowIndex = parseInt(cell.getAttribute('data-row'));
            const columnName = cell.getAttribute('data-column');
            
            // Create input element
            const input = document.createElement('textarea');
            input.className = 'cell-editor';
            input.value = currentValue;
            
            // Position and show input
            cell.style.position = 'relative';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            // Save on Enter or blur
            const saveEdit = () => {
                const newValue = input.value;
                cell.textContent = newValue;
                cell.style.position = '';
                
                // Update the data in mergedData
                let dataToShow = [...mergedData];
                
                // Apply filters to get the correct row index
                if (showUnhealthyOnly) {
                    dataToShow = dataToShow.filter(row => {
                        const status0 = (row['Status0'] || '').toUpperCase();
                        return !status0.includes('FULL_SERVICE');
                    });
                }
                
                if (showUnequalVersionsOnly) {
                    dataToShow = dataToShow.filter(row => {
                        const isSameVersion = (row['Is Same Version'] || '').toLowerCase();
                        return isSameVersion !== 'true';
                    });
                }
                
                const sortedData = sortData(dataToShow, sortColumn, sortDirection);
                
                if (sortedData[rowIndex]) {
                    // Find the original row in mergedData and update it
                    const originalRow = sortedData[rowIndex];
                    const originalIndex = mergedData.findIndex(row => row === originalRow);
                    if (originalIndex !== -1) {
                        mergedData[originalIndex][columnName] = newValue;
                    }
                }
            };
            
            // Cancel on Escape
            const cancelEdit = () => {
                cell.textContent = currentValue;
                cell.style.position = '';
            };
            
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    saveEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit();
                }
            });
        };

        /**
         * Toggles selection of all rows.
         */
        const toggleSelectAll = () => {
            const selectAllCheckbox = document.getElementById('select-all');
            const rowCheckboxes = document.querySelectorAll('.row-checkbox');
            
            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            
            updateDeleteButtonState();
        };

        /**
         * Updates the state of the delete button and selection info.
         */
        const updateDeleteButtonState = () => {
            const selectedCheckboxes = document.querySelectorAll('.row-checkbox:checked');
            const totalRows = document.querySelectorAll('.row-checkbox').length;
            const selectedCount = selectedCheckboxes.length;
            
            // Update delete button state
            deleteSelectedBtn.disabled = selectedCount === 0;
            
            // Update restore button state
            restoreRowsBtn.disabled = deletedRows.length === 0;
            
            // Update selection info
            if (selectedCount === 0) {
                selectionInfo.textContent = `${totalRows} rows total`;
            } else {
                selectionInfo.textContent = `${selectedCount} of ${totalRows} rows selected`;
            }
            
            // Update select all checkbox state
            const selectAllCheckbox = document.getElementById('select-all');
            if (selectAllCheckbox) {
                if (selectedCount === 0) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = false;
                } else if (selectedCount === totalRows) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = true;
                } else {
                    selectAllCheckbox.indeterminate = true;
                }
            }
        };

        /**
         * Deletes selected rows from the table.
         */
        const deleteSelectedRows = () => {
            const selectedCheckboxes = document.querySelectorAll('.row-checkbox:checked');
            
            if (selectedCheckboxes.length === 0) {
                alert('No rows selected for deletion.');
                return;
            }
            
            if (confirm(`Are you sure you want to delete ${selectedCheckboxes.length} selected row(s)?`)) {
                // Get the current filtered data to find the correct rows
                let dataToShow = [...mergedData];
                
                // Apply filters to match what's currently displayed
                if (showUnhealthyOnly) {
                    dataToShow = dataToShow.filter(row => {
                        const status0 = (row['Status0'] || '').toUpperCase();
                        return !status0.includes('FULL_SERVICE');
                    });
                }
                
                if (showUnequalVersionsOnly) {
                    dataToShow = dataToShow.filter(row => {
                        const isSameVersion = (row['Is Same Version'] || '').toLowerCase();
                        return isSameVersion !== 'true';
                    });
                }
                
                // Apply custom filters
                Object.keys(customFilters).forEach(column => {
                    const filterValue = customFilters[column].toLowerCase();
                    if (filterValue) {
                        dataToShow = dataToShow.filter(row => {
                            const cellValue = (row[column] || '').toString().toLowerCase();
                            return cellValue.includes(filterValue);
                        });
                    }
                });
                
                // Collect rows to delete
                const rowsToDelete = [];
                selectedCheckboxes.forEach(checkbox => {
                    const rowIndex = parseInt(checkbox.getAttribute('data-row-index'));
                    const rowToDelete = dataToShow[rowIndex];
                    if (rowToDelete) {
                        rowsToDelete.push(rowToDelete);
                    }
                });
                
                // Move rows to deleted array and remove from mergedData
                rowsToDelete.forEach(rowToDelete => {
                    const originalIndex = mergedData.findIndex(row => 
                        JSON.stringify(row) === JSON.stringify(rowToDelete)
                    );
                    
                    if (originalIndex !== -1) {
                        deletedRows.push(mergedData[originalIndex]);
                        mergedData.splice(originalIndex, 1);
                    }
                });
                
                refreshTable(); // Refresh the table display
                updateStatusMessage(`${rowsToDelete.length} row(s) deleted. ${mergedData.length} rows remaining.`);
            }
        };

        /**
         * Restores all deleted rows.
         */
        const restoreDeletedRows = () => {
            if (deletedRows.length === 0) {
                alert('No deleted rows to restore.');
                return;
            }
            
            if (confirm(`Are you sure you want to restore ${deletedRows.length} deleted row(s)?`)) {
                // Add all deleted rows back to mergedData
                mergedData = mergedData.concat(deletedRows);
                const restoredCount = deletedRows.length;
                deletedRows = []; // Clear deleted rows array
                
                refreshTable(); // Refresh the table display
                updateStatusMessage(`${restoredCount} row(s) restored. ${mergedData.length} rows total.`);
            }
        };

        /**
         * Refreshes the table with current sort and filter settings.
         */
        const refreshTable = () => {
            let dataToShow = [...mergedData];
            
            // Apply unhealthy filter if enabled
            if (showUnhealthyOnly) {
                dataToShow = dataToShow.filter(row => {
                    const status0 = (row['Status0'] || '').toUpperCase();
                    return !status0.includes('FULL_SERVICE');
                });
            }
            
            // Apply unequal versions filter if enabled
            if (showUnequalVersionsOnly) {
                dataToShow = dataToShow.filter(row => {
                    const isSameVersion = (row['Is Same Version'] || '').toLowerCase();
                    return isSameVersion !== 'true';
                });
            }
            
            // Apply custom filters
            Object.keys(customFilters).forEach(column => {
                const filterValue = customFilters[column].toLowerCase();
                if (filterValue) {
                    dataToShow = dataToShow.filter(row => {
                        const cellValue = (row[column] || '').toString().toLowerCase();
                        return cellValue.includes(filterValue);
                    });
                }
            });
            
            const sortedData = sortData(dataToShow, sortColumn, sortDirection);
            
            // Use the current visible headers or fallback to mergedHeaders
            const headersToUse = visibleHeaders.length > 0 ? visibleHeaders : mergedHeaders;
            displayTable(sortedData, headersToUse);
            
            // Update button states after table refresh
            setTimeout(() => {
                updateDeleteButtonState();
            }, 100); // Small delay to ensure DOM is updated
        };

        /**
         * Reprocesses the data with current settings.
         */
        const reprocessData = () => {
            if (mergedData.length === 0) return;
            
            // Get the original data from global variables
            if (window.originalJiraData && window.originalAllServicesData && window.originalServicesFileNames) {
                showUnhealthyOnly = showUnhealthyOnlyToggle.checked;
                showUnequalVersionsOnly = showUnequalVersionsOnlyToggle.checked;
                const { mergedData: reprocessedData, matchesFound } = processMultipleServicesData(
                    window.originalJiraData, 
                    window.originalAllServicesData, 
                    window.originalServicesFileNames
                );
                mergedData = reprocessedData;
                summaryText.textContent = `Processing complete. Found ${matchesFound} matches across ${window.originalJiraData.length} JIRA entries using ${window.originalServicesFileNames.length} services file(s).`;
                refreshTable();
            }
        };

        /**
         * Parses CSV text into an array of objects.
         * It intelligently finds the header row by looking for a key column.
         * @param {string} text - The CSV content as a string.
         * @param {string} keyColumn - A column name that is expected to be in the header.
         * @returns {Array<Object>} An array of objects representing rows.
         */
        const parseCSV = (text, keyColumn) => {
            const lines = text.trim().split(/\r?\n/);
            if (lines.length === 0) return [];

            let headerLineIndex = -1;
            let header = [];

            // Search for the header row in the first 10 lines of the file
            const searchLimit = Math.min(lines.length, 10);
            for (let i = 0; i < searchLimit; i++) {
                // Clean up potential header values
                const potentialHeader = lines[i].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
                if (potentialHeader.includes(keyColumn)) {
                    headerLineIndex = i;
                    header = potentialHeader;
                    break;
                }
            }

            // If no header is found, we can't process the file
            if (headerLineIndex === -1) {
                return [];
            }

            const rows = lines
                .slice(headerLineIndex + 1)
                .map(line => {
                    // Ignore empty lines which might be present in the CSV
                    if (line.trim() === '') return null;

                    const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.trim().replace(/^"|"$/g, ''));
                    const rowObject = {};
                    header.forEach((col, index) => {
                        // Create object properties, skipping columns with no header name
                        if (col) {
                           rowObject[col] = values[index];
                        }
                    });
                    return rowObject;
                })
                .filter(row => row !== null); // Remove the empty lines we marked as null

            return rows;
        };
        
        /**
         * Reads a file and returns its content as text.
         * @param {File} file - The file to read.
         * @returns {Promise<string>} A promise that resolves with the file content.
         */
        const readFileAsText = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsText(file);
            });
        };

        /**
         * Merges JIRA data with multiple Services files.
         * @param {Array<Object>} jiraData - Parsed JIRA CSV data.
         * @param {Array<Array<Object>>} allServicesData - Array of parsed Services CSV data arrays.
         * @param {Array<string>} fileNames - Array of service file names.
         * @returns {{mergedData: Array<Object>, matchesFound: number}} The merged data and match count.
         */
        const processMultipleServicesData = (jiraData, allServicesData, fileNames) => {
            let totalMatchesFound = 0;
            const allProcessedData = [];
            
            // Process each services file with the JIRA data
            allServicesData.forEach((servicesData, fileIndex) => {
                const currentFileName = fileNames[fileIndex];
                
                const processedData = jiraData.map(jiraRow => {
                    const newRow = { ...jiraRow };
                    const summary = (jiraRow['Summary'] || '').toLowerCase();
                    let matchFoundForRow = false;

                    // Add Environment column with the current services file name
                    newRow['Environment'] = currentFileName;

                    if (summary) {
                        for (const serviceRow of servicesData) {
                            let serviceName = (serviceRow['Service0'] || '').toLowerCase();
                            
                            // Always ignore headless suffixes
                            if (serviceName.endsWith('-headless')) {
                                serviceName = serviceName.replace(/-headless$/, '');
                            }
                            
                            if (serviceName) {
                                // Use strict matching to ensure exact service name match
                                // Look for the service name as a complete entity, not as part of a larger hyphenated name
                                // This prevents "manager" from matching "data-sources-manager"
                                const serviceNameRegex = new RegExp('(?:^|\\s)' + serviceName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '(?:\\s|$)', 'i');
                                
                                if (serviceNameRegex.test(summary)) {
                                    // Match found, extend the JIRA row with service data
                                    Object.assign(newRow, serviceRow);
                                    totalMatchesFound++;
                                    matchFoundForRow = true;
                                    break; // Stop after the first match for this JIRA row
                                }
                            }
                        }
                    }

                    // Add "Is Same Version" column logic
                    const version0 = newRow['Version0'];
                    if (version0) {
                        const summaryOriginal = jiraRow['Summary'] || '';
                        const version0Lower = version0.toLowerCase();
                        
                        let isMatch = false;
                        
                        // Look for version patterns like production_w42_20251013 in the summary
                        // Pattern: word_w##_########
                        const versionPattern = /\b([a-zA-Z]+)_(w\d+)_(\d{8})\b/g;
                        const matches = summaryOriginal.toLowerCase().match(versionPattern);
                        
                        if (matches) {
                            // Check each version pattern found in summary
                            for (const match of matches) {
                                const parts = match.split('_');
                                if (parts.length === 3) {
                                    const [environment, week, date] = parts;
                                    
                                    // Check if all three parts exist in Version0
                                    if (version0Lower.includes(environment) && 
                                        version0Lower.includes(week) && 
                                        version0Lower.includes(date)) {
                                        isMatch = true;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // If no pattern found, fall back to simple inclusion check
                        if (!matches) {
                            isMatch = version0Lower.includes(summaryOriginal.toLowerCase());
                        }
                        
                        newRow['Is Same Version'] = isMatch ? 'true' : 'false';
                    } else {
                        // If Version0 doesn't exist, leave empty
                        newRow['Is Same Version'] = '';
                    }

                    return newRow;
                });
                
                // Add all rows from this services file to the combined results
                allProcessedData.push(...processedData);
            });
            
            // Check and populate empty Status0 and Service0 fields
            allProcessedData.forEach(row => {
                const status0Value = (row['Status0'] || '').trim();
                if (!status0Value) {
                    row['Status0'] = 'Data not found !';
                }
                
                const service0Value = (row['Service0'] || '').trim();
                if (!service0Value) {
                    // Try to extract service name from Summary field (word after "Deploy")
                    const summaryValue = (row['Summary'] || '').trim();
                    if (summaryValue) {
                        // Look for the word after "Deploy" (case insensitive)
                        // Include hyphens as part of the word: [\w-]+ matches letters, numbers, underscores, and hyphens
                        const deployMatch = summaryValue.match(/deploy\s+([\w-]+)/i);
                        if (deployMatch && deployMatch[1]) {
                            row['Service0'] = deployMatch[1];
                        } else {
                            row['Service0'] = 'Data not found !';
                        }
                    } else {
                        row['Service0'] = 'Data not found !';
                    }
                }
            });
            
            return { mergedData: allProcessedData, matchesFound: totalMatchesFound };
        };

        /**
         * Displays the merged data in an HTML table.
         * @param {Array<Object>} data - The merged data.
         * @param {Array<string>} headers - The headers for the table.
         */
        const displayTable = (data, headers) => {
            resultsTable.innerHTML = ''; // Clear previous results
            
            // Create table head
            const thead = document.createElement('thead');
            thead.className = "text-xs text-slate-700 uppercase bg-slate-50 sticky top-0";
            const headerRow = document.createElement('tr');
            
            // Add checkbox column header
            const checkboxHeader = document.createElement('th');
            checkboxHeader.scope = 'col';
            checkboxHeader.className = 'px-6 py-3 w-16';
            const selectAllCheckbox = document.createElement('input');
            selectAllCheckbox.type = 'checkbox';
            selectAllCheckbox.id = 'select-all';
            selectAllCheckbox.className = 'rounded border-gray-300';
            selectAllCheckbox.onchange = toggleSelectAll;
            checkboxHeader.appendChild(selectAllCheckbox);
            headerRow.appendChild(checkboxHeader);
            
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.scope = 'col';
                th.className = 'px-6 py-3 sort-header';
                th.setAttribute('data-column', headerText);
                
                // Add header text and sort indicator
                const headerContent = document.createElement('div');
                headerContent.className = 'flex items-center justify-between';
                headerContent.innerHTML = `
                    <span>${headerText}</span>
                    <span class="sort-indicator ${sortColumn === headerText ? 'active' : ''}">${
                        sortColumn === headerText 
                            ? (sortDirection === 'asc' ? '↑' : '↓')
                            : '↕'
                    }</span>
                `;
                th.appendChild(headerContent);
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            resultsTable.appendChild(thead);

            // Create table body
            const tbody = document.createElement('tbody');
            data.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                tr.className = rowIndex % 2 === 0 ? 'bg-white border-b' : 'bg-slate-50 border-b';
                tr.setAttribute('data-row-index', rowIndex);
                
                // Add checkbox cell
                const checkboxCell = document.createElement('td');
                checkboxCell.className = 'px-6 py-4';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'row-checkbox rounded border-gray-300';
                checkbox.setAttribute('data-row-index', rowIndex);
                checkbox.onchange = updateDeleteButtonState;
                checkboxCell.appendChild(checkbox);
                tr.appendChild(checkboxCell);
                
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4 editable-cell';
                    const cellValue = row[header] || '';
                    
                    // Check if this is a Jira Link column and contains HTML
                    if (header === 'Jira Link' && cellValue.includes('<a href=')) {
                        td.innerHTML = cellValue; // Render HTML for links
                        td.classList.remove('editable-cell'); // Don't make links editable
                    } else {
                        td.textContent = cellValue; // Use text content for regular cells
                    }
                    
                    td.setAttribute('data-row', rowIndex);
                    td.setAttribute('data-column', header);
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            resultsTable.appendChild(tbody);
        };
        
        /**
         * Converts an array of objects to a CSV string.
         * @param {Array<Object>} data - The data to convert.
         * @param {Array<string>} headers - The headers for the CSV.
         * @returns {string} The CSV content as a string.
         */
        const convertToCSV = (data, headers) => {
            const headerRow = headers.map(h => `"${h.replace(/"/g, '""')}"`).join(',');
            const bodyRows = data.map(row => {
                return headers.map(header => {
                    const value = row[header] === undefined || row[header] === null ? '' : String(row[header]);
                    return `"${value.replace(/"/g, '""')}"`;
                }).join(',');
            });
            return [headerRow, ...bodyRows].join('\n');
        };

        /**
         * Triggers a file download.
         * @param {string} content - The content of the file.
         * @param {string} fileName - The name of the file to download.
         * @param {string} contentType - The MIME type of the file.
         */
        const downloadFile = (content, fileName, contentType) => {
            const a = document.createElement("a");
            const file = new Blob([content], { type: contentType });
            a.href = URL.createObjectURL(file);
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(a.href);
        };

        /**
         * Copies the table as an image to clipboard.
         */
        const copyTableAsImage = async () => {
            const tableContainer = document.querySelector('.table-container');
            
            if (!tableContainer) {
                setStatus('Table not found for image capture.');
                return;
            }

            setStatus('Capturing table image...', 'loading');

            try {
                // Store original styles
                const originalStyles = {
                    maxHeight: tableContainer.style.maxHeight,
                    overflow: tableContainer.style.overflow,
                    height: tableContainer.style.height
                };

                // Temporarily remove height constraints to show full table
                tableContainer.style.maxHeight = 'none';
                tableContainer.style.overflow = 'visible';
                tableContainer.style.height = 'auto';

                // Wait a bit for the layout to adjust
                await new Promise(resolve => setTimeout(resolve, 100));

                // Configure html2canvas options for better quality
                const canvas = await html2canvas(tableContainer, {
                    backgroundColor: '#ffffff',
                    scale: 2, // Higher resolution
                    useCORS: true,
                    allowTaint: true,
                    scrollX: 0,
                    scrollY: 0,
                    width: tableContainer.scrollWidth,
                    height: tableContainer.scrollHeight,
                    windowWidth: tableContainer.scrollWidth,
                    windowHeight: tableContainer.scrollHeight
                });

                // Restore original styles
                tableContainer.style.maxHeight = originalStyles.maxHeight;
                tableContainer.style.overflow = originalStyles.overflow;
                tableContainer.style.height = originalStyles.height;

                // Convert canvas to blob
                canvas.toBlob(async (blob) => {
                    try {
                        // Use the Clipboard API to copy the image
                        await navigator.clipboard.write([
                            new ClipboardItem({
                                [blob.type]: blob
                            })
                        ]);
                        
                        setStatus('Table image copied to clipboard!', 'success');
                        setTimeout(() => setStatus(''), 2000);
                    } catch (clipboardError) {
                        console.error('Clipboard API failed:', clipboardError);
                        
                        // Fallback: create a download link
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'table-image.png';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        setStatus('Image saved as download (clipboard not supported)', 'success');
                        setTimeout(() => setStatus(''), 3000);
                    }
                }, 'image/png');

            } catch (error) {
                console.error('Failed to capture table as image:', error);
                setStatus('Failed to capture table image. Please try again.');
                
                // Make sure to restore styles even if there's an error
                const tableContainer = document.querySelector('.table-container');
                if (tableContainer) {
                    tableContainer.style.maxHeight = '50vh';
                    tableContainer.style.overflow = 'auto';
                    tableContainer.style.height = '';
                }
            }
        };

        /**
         * Sets the status message and style.
         * @param {string} message - The message to display.
         * @param {'error' | 'loading' | 'success'} type - The type of message.
         */
        const setStatus = (message, type = 'error') => {
            statusContainer.innerHTML = ''; // Clear previous status
            if (!message) return;
            
            const statusDiv = document.createElement('div');
            let classes = 'p-4 rounded-lg text-sm ';
            
            if (type === 'error') {
                classes += 'bg-red-100 text-red-700';
                statusDiv.textContent = `Error: ${message}`;
            } else if (type === 'loading') {
                classes += 'bg-blue-100 text-blue-700 flex items-center justify-center gap-3';
                const loader = document.createElement('div');
                loader.className = 'loader';
                statusDiv.appendChild(loader);
                statusDiv.append(message);
            } else { // success
                classes += 'bg-green-100 text-green-700';
                statusDiv.textContent = message;
            }
            
            statusDiv.className = classes;
            statusContainer.appendChild(statusDiv);
        };

        /**
         * Updates the status message (alias for setStatus with success type).
         * @param {string} message - The message to display.
         */
        const updateStatusMessage = (message) => {
            setStatus(message, 'success');
        };

        // --- Settings Functions ---

        /**
         * Loads Jira deployment links from localStorage.
         */
        const loadJiraDeploymentLinks = () => {
            const savedLinks = localStorage.getItem('jiraDeploymentLinks');
            if (savedLinks) {
                jiraDeploymentLinksInput.value = savedLinks;
            }
        };

        /**
         * Saves Jira deployment links to localStorage.
         */
        const saveJiraDeploymentLinks = () => {
            const links = jiraDeploymentLinksInput.value;
            localStorage.setItem('jiraDeploymentLinks', links);
            setStatus('Settings saved successfully!', 'success');
            setTimeout(() => setStatus(''), 2000);
        };

        /**
         * Opens the settings modal.
         */
        const openSettingsModal = () => {
            loadJiraDeploymentLinks();
            settingsModal.classList.remove('hidden');
            // Focus on the textarea for better UX
            setTimeout(() => {
                jiraDeploymentLinksInput.focus();
            }, 100);
        };

        /**
         * Closes the settings modal and saves the data.
         */
        const closeSettingsModal = () => {
            saveJiraDeploymentLinks();
            settingsModal.classList.add('hidden');
        };

        // --- Jira Links Functions ---

        /**
         * Gets deployment links from localStorage settings.
         * @returns {Array<string>} Array of deployment links.
         */
        const getDeploymentLinks = () => {
            const savedLinks = localStorage.getItem('jiraDeploymentLinks');
            if (!savedLinks || savedLinks.trim() === '') {
                return [];
            }
            return savedLinks.split('\n').map(link => link.trim()).filter(link => link !== '');
        };

        /**
         * Adds Jira links to data based on Service0 column matches with deployment links.
         */
        const addJiraLinks = () => {
            if (mergedData.length === 0) {
                setStatus('No data available. Please process files first.');
                return;
            }

            const deploymentLinks = getDeploymentLinks();
            
            if (deploymentLinks.length === 0) {
                setStatus('No deployment links found. Please add links in Settings first.');
                return;
            }

            let linksAdded = 0;
            let service0Updated = 0;
            
            // Process each row of data
            mergedData.forEach(row => {
                let service0Value = (row['Service0'] || '').trim();
                
                // If Service0 is empty, try to extract from Summary field
                if (!service0Value) {
                    const summaryValue = (row['Summary'] || '').trim();
                    if (summaryValue) {
                        // Look for the word after "Deploy" (case insensitive)
                        // Include hyphens as part of the word: [\w-]+ matches letters, numbers, underscores, and hyphens
                        const deployMatch = summaryValue.match(/deploy\s+([\w-]+)/i);
                        if (deployMatch && deployMatch[1]) {
                            service0Value = deployMatch[1].toLowerCase();
                            row['Service0'] = deployMatch[1]; // Update the actual data
                            service0Updated++;
                        }
                    }
                }
                
                if (service0Value) {
                    service0Value = service0Value.toLowerCase();
                    
                    // Check each deployment link to see if it contains the service name
                    for (const link of deploymentLinks) {
                        const linkLower = link.toLowerCase();
                        
                        // Check if the service name is contained in the link
                        if (linkLower.includes(service0Value)) {
                            // Create HTML link format with "Jira Link" text
                            row['Jira Link'] = `<a href="${link}" target="_blank" rel="noopener noreferrer">Jira Link</a>`;
                            linksAdded++;
                            break; // Only add the first matching link
                        }
                    }
                }
            });

            // Update headers if we added any links
            if (linksAdded > 0) {
                if (!mergedHeaders.includes('Jira Link')) {
                    mergedHeaders.push('Jira Link');
                }
                if (!visibleHeaders.includes('Jira Link')) {
                    visibleHeaders.push('Jira Link');
                }
                
                // Update the column filter
                createColumnFilter(mergedHeaders, visibleHeaders);
                
                // Refresh the table to show the new links
                refreshTable();
                
                let message = `Added ${linksAdded} Jira link(s) successfully!`;
                if (service0Updated > 0) {
                    message += ` Also populated ${service0Updated} empty Service0 field(s) from Summary.`;
                }
                updateStatusMessage(message);
            } else {
                let message = 'No matching services found in deployment links.';
                if (service0Updated > 0) {
                    message += ` However, populated ${service0Updated} empty Service0 field(s) from Summary.`;
                    // Refresh table to show updated Service0 values
                    refreshTable();
                }
                setStatus(message);
            }
        };
        
        // --- Event Handlers ---

        const handleProcess = async () => {
            const jiraFile = jiraFileInput.files[0];
            const servicesFiles = Array.from(servicesFileInput.files);

            // 1. Validation
            if (!jiraFile || servicesFiles.length === 0) {
                setStatus('Please select JIRA CSV and at least one Services CSV file.');
                return;
            }
            setStatus('Processing files...', 'loading');
            processBtn.disabled = true;
            resultsContainer.classList.add('hidden');
            tableControls.classList.add('hidden');

            try {
                // 2. Store services file names, get toggle state, and read files
                servicesFileNames = servicesFiles.map(file => file.name.replace('.csv', ''));
                showUnhealthyOnly = showUnhealthyOnlyToggle.checked;
                showUnequalVersionsOnly = showUnequalVersionsOnlyToggle.checked;
                
                // Read JIRA file
                const jiraText = await readFileAsText(jiraFile);
                
                // Read all services files
                const servicesTexts = await Promise.all(servicesFiles.map(file => readFileAsText(file)));

                const jiraData = parseCSV(jiraText, 'Summary');
                const allServicesData = servicesTexts.map(text => parseCSV(text, 'Service0'));
                
                // Store original data globally for reprocessing
                window.originalJiraData = jiraData;
                window.originalAllServicesData = allServicesData;
                window.originalServicesFileNames = servicesFileNames;
                
                // 3. Check for required columns
                if (jiraData.length === 0) {
                    throw new Error('JIRA CSV is missing data or the "Summary" column could not be found.');
                }
                
                for (let i = 0; i < allServicesData.length; i++) {
                    if (allServicesData[i].length === 0) {
                        throw new Error(`Services CSV "${servicesFiles[i].name}" is missing data or the "Service0" column could not be found.`);
                    }
                }

                // 4. Process the data with multiple services files
                const { mergedData: processedData, matchesFound } = processMultipleServicesData(jiraData, allServicesData, servicesFileNames);
                
                // 4.5. Expand columns with multiple links
                const { expandedData, newHeaders: linkHeaders } = expandLinksIntoColumns(processedData);
                mergedData = expandedData; // Store globally for download

                // 5. Determine all unique headers for the final table (including Environment, Is Same Version, and link columns)
                const jiraHeaders = Object.keys(jiraData[0] || {});
                const allServicesHeaders = allServicesData.flat().reduce((acc, serviceData) => {
                    return [...acc, ...Object.keys(serviceData)];
                }, []);
                const uniqueServicesHeaders = [...new Set(allServicesHeaders)];
                mergedHeaders = [...new Set(['Environment', ...jiraHeaders, ...uniqueServicesHeaders, 'Is Same Version', ...linkHeaders])]; // Store globally with Environment first and Is Same Version last

                // 6. Display results
                initializeSortOptions(mergedHeaders);
                createColumnFilter(mergedHeaders);
                displayTable(mergedData, visibleHeaders);
                summaryText.textContent = `Processing complete. Found ${matchesFound} matches across ${jiraData.length} JIRA entries using ${servicesFiles.length} services file(s).`;
                setStatus('', 'success'); // Clear loading status
                resultsContainer.classList.remove('hidden');
                tableControls.classList.remove('hidden');

            } catch (error) {
                console.error("Processing failed:", error);
                setStatus(error.message || 'An unexpected error occurred.');
                resultsContainer.classList.add('hidden');
                tableControls.classList.add('hidden');
            } finally {
                processBtn.disabled = false;
            }
        };

        const handleDownload = () => {
            if (mergedData.length === 0) {
                setStatus('No data available to download.');
                return;
            }
            
            // Get the exact same data that's currently shown in the table
            let dataToDownload = [...mergedData];
            
            // Apply the same filters as in refreshTable
            if (showUnhealthyOnly) {
                dataToDownload = dataToDownload.filter(row => {
                    const status0 = (row['Status0'] || '').toUpperCase();
                    return !status0.includes('FULL_SERVICE');
                });
            }
            
            if (showUnequalVersionsOnly) {
                dataToDownload = dataToDownload.filter(row => {
                    const isSameVersion = (row['Is Same Version'] || '').toLowerCase();
                    return isSameVersion !== 'true';
                });
            }
            
            // Apply the same sorting as in refreshTable
            const sortedData = sortData(dataToDownload, sortColumn, sortDirection);
            
            // Use only visible headers (filtered columns)
            const csvContent = convertToCSV(sortedData, visibleHeaders);
            downloadFile(csvContent, 'merged_jira_data.csv', 'text/csv;charset=utf-8;');
        };

        const handleCopyAsImage = () => {
            if (mergedData.length === 0) {
                setStatus('No data available to copy.');
                return;
            }
            
            copyTableAsImage();
        };

        // --- Attach Event Listeners ---
        processBtn.addEventListener('click', handleProcess);
        downloadBtn.addEventListener('click', handleDownload);
        copySlackBtn.addEventListener('click', handleCopyAsImage);
        
        // Sort controls
        sortColumnSelect.addEventListener('change', (e) => {
            sortColumn = e.target.value;
            refreshTable();
        });
        
        sortDirectionBtn.addEventListener('click', () => {
            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            sortDirectionBtn.textContent = sortDirection === 'asc' ? '↑ ASC' : '↓ DESC';
            refreshTable();
        });
        
        // Table header clicks for sorting
        resultsTable.addEventListener('click', (e) => {
            const header = e.target.closest('.sort-header');
            if (header) {
                const column = header.getAttribute('data-column');
                if (sortColumn === column) {
                    sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    sortColumn = column;
                    sortDirection = 'asc';
                }
                sortColumnSelect.value = sortColumn;
                sortDirectionBtn.textContent = sortDirection === 'asc' ? '↑ ASC' : '↓ DESC';
                refreshTable();
            }
        });
        
        // Table cell editing
        resultsTable.addEventListener('click', (e) => {
            const cell = e.target.closest('.editable-cell');
            if (cell && !cell.querySelector('.cell-editor')) {
                makeEditable(cell);
            }
        });
        
        // Column filter chips
        columnFilter.addEventListener('click', (e) => {
            if (e.target.classList.contains('column-chip-remove')) {
                const columnToRemove = e.target.getAttribute('data-column');
                removeColumn(columnToRemove);
            }
        });
        
        // Show all columns button
        showAllColumnsBtn.addEventListener('click', showAllColumns);
        
        // Show unhealthy only toggle
        showUnhealthyOnlyToggle.addEventListener('change', () => {
            showUnhealthyOnly = showUnhealthyOnlyToggle.checked;
            refreshTable();
        });
        
        // Show unequal versions only toggle
        showUnequalVersionsOnlyToggle.addEventListener('change', () => {
            showUnequalVersionsOnly = showUnequalVersionsOnlyToggle.checked;
            refreshTable();
        });
        
        // Delete selected rows button
        deleteSelectedBtn.addEventListener('click', deleteSelectedRows);
        
        // Restore deleted rows button
        restoreRowsBtn.addEventListener('click', restoreDeletedRows);
        
        // Add Jira links button
        addJiraLinksBtn.addEventListener('click', addJiraLinks);
        
        // Settings modal event listeners
        settingsBtn.addEventListener('click', openSettingsModal);
        settingsBackBtn.addEventListener('click', closeSettingsModal);
        
        // Close modal when clicking outside of it
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                closeSettingsModal();
            }
        });
        
        // Auto-save on input changes (with debounce)
        let saveTimeout;
        jiraDeploymentLinksInput.addEventListener('input', () => {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                localStorage.setItem('jiraDeploymentLinks', jiraDeploymentLinksInput.value);
            }, 1000); // Save after 1 second of no typing
        });
    </script>

</body>
</html>

